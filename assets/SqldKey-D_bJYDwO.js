import{_ as b,c as t,b as e,o as s}from"./index-C3RhNgxk.js";const o={},d={class:"flex flex-col gap-5"};function p(a,r){return s(),t("div",d,r[0]||(r[0]=[e('<h1 class="text-3xl font-bold">식별자 Key</h1><p> 식별자는 엔터티를 대표할 수 있는 속성을 의미하며, 일반적으로 <strong class="text-blue-600">키(Key)</strong>라고 부릅니다. <br> 논리적 모델링 단계에서는 <strong class="text-blue-600">식별자</strong>, 물리적 모델링 단계에서는 <strong class="text-blue-600">키</strong>라는 용어를 사용합니다. <br></p><p> 이 중에서도 <strong class="text-blue-600">주식별자</strong>는 해당 엔터티를 대표하는 기본 키로, <br> 최소한의 속성만으로 각 인스턴스를 고유하게 구분하는 역할을 합니다. <br> 주식별자는 자주 사용되는 속성을 기반으로 선정하며, <br> 단순히 명칭이나 내역 같은 설명적 정보보다는 <strong class="text-blue-600">대표성과 구분 가능성</strong> 을 중시합니다. <br></p><table class="border-collapse border border-gray-300 w-80 text-center"><thead><tr><th class="border border-gray-300 px-4 py-2">번호</th><th class="border border-gray-300 px-4 py-2">이름</th><th class="border border-gray-300 px-4 py-2">성별</th></tr></thead><tbody><tr><td class="border border-gray-300 px-4 py-2">1</td><td class="border border-gray-300 px-4 py-2">홍길동</td><td class="border border-gray-300 px-4 py-2">남자</td></tr><tr><td class="border border-gray-300 px-4 py-2">2</td><td class="border border-gray-300 px-4 py-2">심청이</td><td class="border border-gray-300 px-4 py-2">여자</td></tr></tbody></table><p> 해당 테이블에서 [번호]를 주식별자로 선정하면 번호에 따라 사람이 구분됩니다. <br> 주식별자를 (이름,성별)로 구성하면 동명이인이 있을 때 구분이 안되는 오류가 있겠죠 <br> 그래서 최소한의 구분 가능한 속성을 사용합니다. <br></p><p> 주식별자의 특징으로는 다음과 같습니다. <br> 유일성 : 키를 사용하면 모든 인스턴스를 유일하게 구분할 수 있음 <br> 최소성 : 주식별자는 유일성을 만족하는 최소한의 구성으로 만들어야 함 <br> 불변성 : 주식별자가 한번 특정 엔터티에 지정되면 변하지 않음 (고유) <br> 존재성 : 주식별자로 지정되면 반드시 값이 있어야 함. NULL값 비허용 <br></p><p> 키의 종류는 아래와 같습니다. <br> 기본키 : 엔터티를 대표할 수 있는 키 (주식별자) <br> 후보키 : 유일성과 최소성을 만족. 후보키 중 하나가 기본키가 되고 나머지는 전부 대체키가 됨. <br> 대체키 : 후보키에서 기본키가 아닌 모든 값. <br> 슈퍼키 : 유일성은 만족하지만 최소성을 만족하지 못한 키. <br> 외래키 : 다른 테이블의 기본키를 참조하는 키. <br></p><p> 식별자를 분류 할 수 있는 방법은 4가지가 있습니다. <br> 1. 대표성 여부에 따른 식별자의 종류 (주식별자/보조식별자) <br> 2. 생성 여부에 따른 식별자의 종류 (내부식별자/외부식별자) <br> 3. 속성 수에 따른 식별자의 종류 (단일식별자/복합식별자) <br> 4. 대체 여부에 따른 식별자의 종류 (본질식별자/인조식별자) <br></p><p> 내용은 간단합니다. 보통은 기준이 기본키일 가능성이 높습니다. <br> 주식별자 = 기본키 / 보조식별자 = 대체키 <br> 내부식별자 = 기본키 / 외부식별자 = 외래키 <br> 기본키 속성이 1개 = 단일식별자 / 기본키 속성이 N개 묶음 = 복합식별자 <br> 실질적으로 값을 가지고 속성으로 구분 가능 = 본질식별자 / 튜플 번호 자동 값 증가 = 인조식별자 <br></p><p> 엔터티는 관계를 기준으로 구분 가능합니다. <br> 강한 개체는 독립적으로 존재가 가능하며, 약한 개체는 독립적이지 못하고 다른 엔터티에 의존해야 합니다. <br></p><p> 식별 관계는 부모 엔터티의 기본키를 참조해 사용하는 방식입니다. <br> 부모에게서 받은 값과, 자식의 키를 합쳐 복합적으로 기본키를 구성하는 경우입니다. <br> (다이어그램에서 실선으로 표현합니다) <br> 부모 엔터티 기본키 : 주문번호 <br> 자식 엔터티 기본키 : [주문번호+상품번호](기본 키, 복합 기본키) 이런 식으로 쓸 수 있습니다. <br></p><p> 비식별 관계는 부모 엔터티에서 외래키로 값을 불러오지만, 이를 기본키 값으로 설정하지 않는 참조 역할인 경우입니다. <br> 부모 엔터티 기본키 : 사용자 ID <br> 자식 엔터티 : 사용자ID(외래키), 글ID(기본키) <br> (다이어그램에서 점선으로 표현합니다) <br></p>',12)]))}const c=b(o,[["render",p]]);export{c as default};
