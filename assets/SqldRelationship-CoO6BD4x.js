import{_ as s,c as e,b as r,o}from"./index-C3RhNgxk.js";const l={},n={class:"flex flex-col gap-5"};function a(b,t){return o(),e("div",n,t[0]||(t[0]=[r('<h1 class="text-3xl font-bold">관계 Relationship</h1><p><strong class="text-blue-600">관계</strong>는 데이터베이스에서 <strong class="text-blue-600">엔터티(테이블)</strong> 간의 논리적인 연관성을 의미합니다. <br> 이는 단순히 데이터를 연결하는 것을 넘어, 데이터의 의미를 부여하고 구조를 형성하는 데 매우 중요합니다. </p><p> 관계는 크게 두 가지 종류로 분류할 수 있지만, <br> ERD(개체-관계 다이어그램)에서 명확히 구분하지는 않습니다. </p><p> 1. 존재 관계: 한 엔터티의 존재가 다른 엔터티에 영향을 미치는 관계입니다. <br> 2. 행위 관계: 엔터티 간에 어떤 행위가 일어나는 관계입니다. </p><h2 class="text-blue-600 font-bold text-xl my-2">관계의 구성 요소</h2><p>관계는 주로 세 가지 요소로 구성됩니다.</p><p> 1. 관계명 (Relationship Name): 관계의 의미를 나타내는 이름입니다. <br> 2. 차수 (Cardinality): 두 엔터티 간에 참여하는 <strong class="text-blue-600">인스턴스(레코드)</strong>의 수적 비율을 나타냅니다. <br> 3. 선택성 (Optionality): 관계에 반드시 참여해야 하는지, 아니면 선택적으로 참여할 수 있는지 나타냅니다. </p><p> 차수에 대해 추가적으로 설명하겠습니다 <br> - 1대1 : 하나의 엔터티 인스턴스가 다른 엔터티 인스턴스 하나와 연결됩니다. <br> - 1대N : 하나의 엔터티 인스턴스가 다른 엔터티의 여러 인스턴스와 연결됩니다. (가장 흔한 관계 유형) <br> - M대N : 여러 엔터티 인스턴스가 다른 여러 엔터티 인스턴스와 연결됩니다. </p><h2 class="text-blue-600 font-bold text-xl my-2">추가 개념</h2><p> 조인 (JOIN): 이미 정의된 관계를 기반으로, 여러 테이블에 흩어져 있는 데이터를 하나로 합쳐서 조회하는 SQL 연산입니다. <br><br> 재귀적 관계 (Recursive Relationship): 같은 엔터티 내의 인스턴스가 관계를 맺는 경우입니다. <br> 셀프조인이며, 직원 테이블에서 관리자와 부하 직원의 관계를 나타낼 때 사용됩니다. <br><br> 다대다(M:N) 관계의 처리: 관계형 데이터베이스에서 M:N 관계는 직접 표현하기 어렵습니다. <br> 따라서 중간에 <strong class="text-blue-600">연결 엔터티(Junction Entity)</strong>를 추가하여 두 개의 1:N 관계로 변환하여 관리합니다. <br> 이는 데이터를 효율적으로 저장하고 관리하기 위한 중요한 설계 기법입니다. </p>',10)]))}const c=s(l,[["render",a]]);export{c as default};
